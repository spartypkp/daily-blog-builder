{
    "date": "2024-09-05",
    "introduction": {
        "personal_context": "I finally got a good night of sleep. I sometimes struggle with insomnia (see caffeine addiction and adderall). However, I got a full 10 hours of sleep and woke up early to start the day. Feeling good. This is going to be my first blog. I'm really excited, and very nervous, to write it.",
        "daily_goals": "Today's goals are simple. I want to create and develop a \"Daily Blog Builder\", which is a tool for helping me to create my Daily Blogs for the \"iwanttobeanaiengineer.com\" website. I already have made a home page for the website in NextJS, but I have no good tool for writing blogs. I want to build something custom for me, helping me overcome my fear of oversharing over the internet. This tool would have to be some kind of local, easy to use, and simple tool where I could write my blogs throughout a given day. Every day I need to make one, and so I need some kind of tool. Google docs, JSON files, or writing on paper isn't going to cut it. The purpose of a blog builder is a little bit deeper. I need a way to easily write throughout the day, adding screenshots and code snippets, in a single place. I need some kind of tool that allows me to automatically upload to my NextJS website at the end of the day. I need a tool which will eventually allow for easier AI integration, not just in the editing of my blog posts, but in the daily writing of them. And most importantly, I needed to develop some type of structure for my thoughts. Some way to capture the interesting things I'm doing, highlight interesting problems i run into, and also of course showcase my skills as an AI Engineer.",
        "learning_focus": "Today I want to hone some of my regular software engineering skills. I'm hoping to go over again some web development basics, by building a relatively simple flask app. I plan to touch on my database skills (which are already strong), and hopefully if I have time get to some actual AI engineering.",
        "challenges": "Well the first and most important challenge is the problem of organization. I'm not a writer, I always find it hard to put myself out on social media, and I don't READ a lot of peoples blog posts. I don't know what a good blog looks like. I don't know how to write one. And if I did write one, it would be rambling and incoherent. Today's main challenge is attempting to give structure to a daily blog post. End of day Will here: I thought I was finished with my tasks for today and so I moved on to AI Engineering. And throughout my testing I found AI responses lacking. Well, to be honest, it was my original lackluster blog orginization structure to blame. So I went back and refactored EVERYTHING to use a much more structured format. More on that later.",
        "plan_of_action": "I want to attack this project with some coordinated steps. My dream is to have an easy to use, local, automated way of writing throughout the day and tracking what I work on. I have big plans for AI integration, but for now I will plan to focus on the actual core \"Blog Builder\" tool first. No sense in having an AI edit my blogs, or suggest real time improvements, if my blog writing sucks in the first place. Anyways, here's the following steps:\n1. Create a list of requirements for what the Blog Builder tool needs.\n2. Do some research (thanks ChatGPT!) into some possible technologies and routes for building this.\n3. Decide on a tech stack\n4. Build a barebones version of the Blog App frontend.\n5. Hook up the frontend with my backend, using Postgres to store all daily blog data.\n6. Build saving and loading features from the frontend to the backend and vice versa. Don't want to spend hours on a blog and then accidentally tab out, losing all my progress. (totally didn't happen earlier in the day today once)\n7. Spend some serious time refining the structure/organization/schema of my Blog Builder. What input fields do I want? How should I separate them out into categories? What types of fields are each? I specifically put this AFTER initial testing. I wanted to test out using a stupid barebones version so I could get some thoughts on what I want.\n8. Refactor all the integrations between my frontend and backend and backend to database using PYDANTIC. My absolute favorite Python library. In fact, I already have so many custom SQL <-> Pydantic functions that the backend to database connections will be super duper easy.\n9. Fully test out the saving and loading of daily blogs between my system. Try to break out. Try to fix it.\n10. Write a full initial blog.\n11. Add extra features, such as image embedding and code chunks.\n12. Work on testing out an AI prompt pipeline for Dave, my AI editor, to edit finished blogs. (WARNING: Future Will Here, this is the point in my progress that I realized my structure of blog inputs was severely lacking. I ended up doing a full refactor of my SQL schema, Pydantic models, and HTML inputs)\n13. ....?\n14. Profit",
        "focus_level": 84,
        "enthusiasm_level": 100,
        "burnout_level": 1,
        "leetcode_hatred_level": 99
    },
    "tasks": [
        {
            "task_goal": "Develop a MVP build for my \"Blog Builder\" tool, which will serve as a tool for creating daily progress blogs, editing with AI help, and then posting to my website.",
            "task_description": "The first part of building my \"Blog Builder\" is deciding what I want to build! I only have some loose requirements for the tool, and I'm really unsure of what the final tool will look like. This will involve thinking about what features the blog should have, doing research on possible technologies to use, choosing a tech stack, and then building the \"Blog Builder\" tool itself. Obviously, building the barebones \"Blog Builder\" will be the most time consuming task, however I am purposefully keeping this step vague to allow for more flexibility in design choices and rapid iteration (my speciality)",
            "task_expected_difficulty": 25,
            "task_planned_approach": "1. Create a list of requirements for what the Blog Builder tool needs.\n- What should it look like?\n- How can I make it easier to use for myself?\n- How can I focus on MVP first?\n- Although MVP won't include AI integrations, how can I plan for future further AI integrations?\n- How might I need to connect it to my website automatically?\n2. Do some research (thanks ChatGPT!) into some possible technologies and routes for building this.\n- I'm leaning towards something local and simple. I'm thinking about using Python for the backend, as it's my favorite language and I have some experience building backends in FastAPI. I'm going to look into Flask or Django to do the backend.\n- Frontend has to be simple local HTML. (localhost enjoyers rejoice!) I don't want to overcomplicate the tool, I briefly thought about integrating the tool into my hosted NextJS website, where I have more experience, but there's no reason it needs to be on a hosted server.\n- Database is going to be PostgreSQL. Next Question\n- I want to use Pydantic throughout my backend. I like it for the strong typing, I already use it extensively to interact with PostgreSQL, and it works really well with the Instructor library and LLM structured outputs. Yes, Pydantic is my comfort library. \n3. Decide on a tech stack\n- Depends on research, but I already have some favored choices.\n4. Build a barebones version of the Blog App frontend.\n- Single page HTML frontend, with the capability of filling in forms/text fields to write a blog throughout the day. Must be able to save results to my database, integrate everything with my backend in Python. Optionally I would really like to figure out how to add more content than JUST text.",
            "task_progress_notes": "<p>My day started out by thinking about a list of requirements for the blog builder. I already detailed these requirements in the daily goals. I jumped right into research with ChatGPT, my favorite partner programming rubber ducky. After discussing with ChatGPT, it became clear that Flask would probably be the best choice. It would allow me the most flexibility and speed to MVP. I wanted something simple, and this would do the trick. I can use Python for my entire backend, while also using Pydantic models to pass data in a more structured way. I already extensively use Pydantic when interacting with SQL tables, and imported some of my common used functions. The function I show below is a simple generic python function for writing a select query on a given table, and returning all results as a List of pydantic models. Provide the table name, and the Pydantic type you want returned, and bam it works. It is considered bad practice to use Python f string formatting to inject the table name directly, however I don't care. I will always be manually specifying the table name, which is never derived from user input. I have some experimental versions of this function which use more safe Psycopg3 parameterized inputs, but that's still in development. I currently have separate functions for all the main SQL query types. In the future, I hope to finish my work on developing a generic function and library for interacting with SQL purely through Pydantic Models (which can be auto generated!). This will likely be a future blog post, so stick around! </p><pre class=\"ql-syntax\" spellcheck=\"false\">def pydantic_select(sql_select: str, modelType: Type[BaseModel]) -&gt; List[Any]:\n    \"\"\"\n    Executes a SQL SELECT statement and returns the result rows as a list of Pydantic models.\n\n\n    Args:\n        sql_select (str): The SQL SELECT statement to execute.\n        modelType (Optional[Any]): The Pydantic model to use for the row factory\n\n\n    Returns:\n        List[Any]: The rows returned by the SELECT statement as a list of Pydantic Models.\n    \"\"\"   \n    # Use the provided modelType (PydanticModel) for the row factory\n    if modelType:\n        conn = db_connect(row_factory=class_row(modelType))\n    \n\n\n    cur = conn.cursor()\n\n\n    # Execute the SELECT statement\n    cur.execute(sql_select)\n\n\n    # Fetch all rows\n    rows = cur.fetchall()\n    \n\n\n    # Close the cursor and the connection\n    cur.close()\n    conn.close()\n\n\n    return rows\n</pre><p><br></p><p>As I was looking for that pydantic_select function, I realized I have the same function defined in 10 different repositories. Some are slightly different, with slight enhancements and changes I've made throuhgout my Pydantic journey. I really need to go back and standardize. I think I need a better system for versioning across repos. Putting a mental note to be a smarter software engineer and find a solution for that.</p><p><br></p><p>The next step is of course to design the schema and structure of a daily blog post. I need to decide on what information I need to capture each day in all my blogs. How do I want to go about designing this? I started this process by deciding to split a given single blog post into 3 separate sections. There's an introduction, which occurs at the beginning of each day, and contains information about my goals, description of the problem, plan of attack, and some other fun mood sliders. The last section is the reflection, where I can reflect on the progress of the day and how i did or did not achieve my goals. I struggled to come up with a solid idea for tracking my work during the bulk of the day, where I'm working on different projects and tasks for different amount of time. I could be working on scraping legislation, practicing leetcode, working my part time AI Engineer consulting job, or building numerous different side projects. I needed something flexible that allowed me to track multiple different unique tasks throughout the day. I decided on building a dynamic task system, where I could track progress for 1 to N number of tasks I complete during the day. How I break up my goals into tasks will be left completely up to me (for now, maybe I'll integrate Dave to help me later). Each task has information on the task, description, and tracks some important information like \"Challenges Encountered\" and \"Research Questions\".</p><p><br></p><p>The first step to implementing my blog schema is to structure my thoughts into you guessed it, a Pydantic model! And because I love Pydantic and Postgres so much, I can concurrently create the schema for my backend data and my database. I map Pydantic models directly into PostgreSQL table schemas. The trick is to use JSONB for complex nested fields, which the corresponding Pydantic model represents as another Pydantic model! This allows for rapid iteration of design. As long as I get some of the key metadata fields right, I can effortlessly update how I structure and store data without ever having to worry about updating SQL schema. This can be incredibly important when doing rapid prompt engineering. In this case, I've developed Pydantic models for the \"Introduction\", \"Tasks\", and \"Reflection\" sections of each Daily Blog. Those are represented as JSONB in SQL, and have their own submodels in Python. Here's the code!</p><pre class=\"ql-syntax\" spellcheck=\"false\"># Submodel for Task\nclass Task(BaseModel):\n    # Task Start - filled out at start of task\n    task_goal: Optional[str] = Field(\"\", description=\"Desired outcome or goal for the task.\")\n    task_description: Optional[str] = Field(\"\", description=\"Description of the task or problem.\")\n    task_expected_difficulty: Optional[int] = Field(50, description=\"Focus level (0-100).\", ge=0, le=100)\n    task_planned_approach: Optional[str] = Field(\"\", description=\"Method or strategy Will plans to use to tackle the problem.\")\n\n\n    # Task Work - Ongoing throughout day\n    task_progress_notes: Optional[str] = Field(\"\", description=\"Main writing area for Will to document  his progress.\")\n    challenges_encountered: Optional[str] = Field(\"\", description=\"Key challenges or bugs encountered.\")\n    research_questions: Optional[str] = Field(\"\", description=\"An always updated list of research questions Will had while working on the task\")\n    \n    # Task Reflection - filled out after task completion\n    tools_used: Optional[str] = Field(\"\", description=\"Key tools, libraries, or frameworks used during the task.\")\n    reflection_successes: Optional[str] = Field(\"\", description=\"What worked well during the task?\")\n    reflection_failures: Optional[str] = Field(\"\", description=\"What didn't work, and why?\")\n    output_or_result: Optional[str] = Field(\"\", description=\"The outcome or deliverable from this task (e.g., code, documentation).\")\n    time_spent_coding: Optional[str] = Field(\"\", description=\"Time spent actively coding (e.g., '2 hours').\")\n    time_spent_researching: Optional[str] = Field(\"\", description=\"Time spent researching (e.g., '30 minutes').\")\n    time_spent_debugging: Optional[str] = Field(\"\", description=\"Time spent debugging (e.g., '45 minutes').\")\n    follow_up_tasks: Optional[str] = Field(\"\", description=\"Immediate next steps or follow-up tasks.\")\n\n\nclass Introduction(BaseModel):\n    personal_context: Optional[str] = Field(\"\", description=\"Additional context for the day (e.g., external factors).\")\n    daily_goals: Optional[str] = Field(\"\", description=\"Main tasks or goals for the day.\")\n    learning_focus: Optional[str] = Field(\"\", description=\"What Will wants to learn or improve on today.\")\n    challenges: Optional[str] = Field(\"\", description=\"Known challenges or experiments for the day.\")\n    plan_of_action: Optional[str] = Field(\"\", description=\"Will's initial plan for tackling the daily_goals and challenges today.\")\n\n\n    focus_level: Optional[int] = Field(50, description=\"Focus level (0-100).\", ge=0, le=100)\n    enthusiasm_level: Optional[int] = Field(50, description=\"Enthusiasm meter (0-100).\", ge=0, le=100)\n    burnout_level: Optional[int] = Field(50, description=\"Burnout meter (0-100).\", ge=0, le=100)\n    leetcode_hatred_level: Optional[int] = Field(99, description=\"LeetCode hatred meter (0-100).\", ge=0, le=100)\n    \nclass Reflection(BaseModel):\n    technical_challenges: Optional[str] = Field(\"\", description=\"Notable technical challenges or obstacles faced.\")\n    interesting_bugs: Optional[str] = Field(\"\", description=\"Details of any interesting bugs encountered.\")\n    unanswered_questions: Optional[str] = Field(\"\", description=\"Unanswered technical questions or topics for further research.\")\n    learning_outcomes: Optional[str] = Field(\"\", description=\"Key takeaways and things learned during the day.\")\n    next_steps_short_term: Optional[str] = Field(\"\", description=\"Immediate next steps or tasks for tomorrow.\")\n    next_steps_long_term: Optional[str] = Field(\"\", description=\"Long-term goals or ongoing technical objectives.\")\n    \n    # Humorous &amp; Self-Reflective Mood Sliders\n    productivity_level: Optional[int] = Field(50, description=\"Self-evaluation: Productivity (0-100).\", ge=0, le=100)\n    distraction_level: Optional[int] = Field(50, description=\"Self-evaluation: How Distracted were you (0-100).\", ge=0, le=100)\n    desire_to_play_steam_games_level: Optional[int] = Field(50, description=\"Desire to play Steam games (0-100). It's always Europa Universalis IV\", ge=0, le=100)\n    overall_frustration_level: Optional[int] = Field(50, description=\"Frustration level (0-100).\", ge=0, le=100)\n\n\n# Main model for the Daily Blog\nclass DailyBlog(BaseModel):\n    date: datetime.date = Field(..., description=\"Date of the blog entry.\")\n    introduction: Optional[Introduction] = Field(default=Introduction(), description=\"The introduction to Will's daily blog.\")\n    tasks: List[Task] = Field(default_factory=lambda: [Task()], description=\"List of technical tasks Will completed for the day.\")\n    reflection: Optional[Reflection] = Field(default=Reflection(), description=\"The reflection portion of Will's daily blog\")\n    created_at: Optional[datetime.datetime] = Field(default=None, description=\"Timestamp for when the blog was created.\")\n    updated_at: Optional[datetime.datetime] = Field(default=None, description=\"Timestamp for the last update.\")\n</pre><p>I really enjoy using the Field() feature of Pydantic, which allows me to set default values and add extensive descriptions, as well as constraints for improved automatic value validation. Also, I hope you see how I avoid using camelCase like the plague. I want the name of my Pydantic model fields to EXACTLY match the SQL column names. Now this naming, doesn't technically matter for submodels, which will be thrown into JSONB, but I like to be consistent. Speaking of JSONB, here's the SQL schema for the daily_blogs table!</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">CREATE TABLE daily_blogs (\n\n&nbsp; &nbsp; date date PRIMARY KEY,\n\n&nbsp; &nbsp; introduction jsonb,\n\n&nbsp; &nbsp; tasks jsonb,\n\n&nbsp; &nbsp; reflection jsonb,\n\n&nbsp; &nbsp; created_at timestamp with time zone DEFAULT now(),\n\n&nbsp; &nbsp; updated_at timestamp with time zone DEFAULT now()\n\n);\n</pre><p>Shout out Postico, the best investment I ever made. As you can see, this table is brutally simple. I like to keep complex design and typing within the backend and out of the database. JSONB is great because it allows for incredible flexiblity in rapid iteration of schema, and I can still create complex SQL queries which access underlying data within JSONB columns. To my naive junior software development mind, this is an acceptable tradeoff. I love it. </p><p><br></p><p>I now need to set up my backend, super simple at first. I'm using Flask, and only need a couple of main routes.</p><p>My file system structure is stupid simple, and took me and ChatGPT about 5 minutes to setup. </p><p><img src=\"/static/uploads/Screenshot_2024-09-06_at_1.17.11_PM.png\" style=\"width: 30%; height: auto;\"></p><p><br></p><p>I've got a super simple setup here. I've got a home route, which gets the current blog for the day or creates an empty one, and then renders the home page with it.</p><ul><li>/api/today_blog route offers up the daily blog. It's useful because my Javascript function will ask for the daily blog to populate all of the daily tasks dynamically. I'm just now noticing it has a /api/ in the route. Bad ChatGPT, that's completely unnecessary.</li><li>/submit_blog reads in the values of all my forms and text areas for a daily blog, loads it into a Pydantic model, and then saves it to Postgres. Simple.</li><li>/upload_image is a route that handles the saving of image uploads into the repository. This is necessary to override the default functionality of Quill, a rich text editor for Javascript. </li></ul><p>Next it was necessary to start working on the frontend. To be honest, I worked simultaneously on the frontend as I was building out some of the functionality of the API routes. But for easier understanding, I'm talking about these two separately. First step was to start building out the frontend. I started by prompting ChatGPT to develop 3 distinct sections of content in the body, as well as set up Tailwind and the rest of the HTML document. There are 3 distinct sections corresponding to the Pydantic Model: introduction, tasks, and of course reflection. Here's an image of a VERY early version of the frontend. </p><p><img src=\"/static/uploads/Screenshot_2024-09-05_at_10.09.28_AM.png\" style=\"width: 30%; height: auto;\"></p><p><br></p><p>After some iteration, I was able to fully flesh out the correct input areas for ALL of the fields of the Pydantic model. I was very careful to make the ID of each input element the exact field name of the Pydantic model, to allow for super easy access. Smort. To be completely honest, this is the point where a lot of design iteration happened. I redesigned my Pydantic model a lot. I added new fields. I tested out new HTML. At this point I even started to write a partial blog. However, this blog eventually had to be overwritten, as I made simply too much radical changes to the Pydantic model schema and SQL table, and opted to simply restart. So if you feel as if I'm extra omnitient in this blog, that's why! I really do want to focus on writing the blogs more as I go, but I'll cut myself some slack as this is my first blog. Also, it's very difficult to use a tool which you are in the process of developing. So cut me some slack Dave. Here's a finalized version of the current introduction section, filled with text I am currently writing for the blog.</p><p><img src=\"/static/uploads/Screenshot_2024-09-06_at_1.37.40_PM.png\" style=\"width: 30%; height: auto;\"></p><p>My next step was to connect my frontend with my backend. I needed to write a bunch of different scripts, which would handle data loading between my backend. Possibly the most important function is the initializeBlog() function. This function takes in a Pydantic model of the blog data, dumped to JSON, and uses it to set the html of all my data input HTML elements. Simple, but works. And because I made the id of each element to map directly to my Pydantic model field names, it's super clean and easy. After adding all of the introduction and reflection sections, I have to iterate over all of the possible daily tasks and generate those separately. Onward!</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">let currentTaskId = 0; // Start from 1 because the initial task is already there\n\n\nfunction initializeBlog(blogData) {\n    \n    // Set the values for Introduction section fields\n    if (blogData.introduction) {\n        document.getElementById('daily_goals').value = blogData.introduction.daily_goals || '';\n        document.getElementById('learning_focus').value = blogData.introduction.learning_focus || '';\n        document.getElementById('challenges').value = blogData.introduction.challenges || '';\n        document.getElementById('plan_of_action').value = blogData.introduction.plan_of_action || '';\n        document.getElementById('personal_context').value = blogData.introduction.personal_context || '';\n\n\n        // Set the mood sliders\n        document.getElementById('enthusiasm_level').value = blogData.introduction.enthusiasm_level || 50;\n        document.getElementById('burnout_level').value = blogData.introduction.burnout_level || 50;\n        document.getElementById('focus_level').value = blogData.introduction.focus_level || 50;\n        document.getElementById('leetcode_hatred_level').value = blogData.introduction.leetcode_hatred_level || 50;\n    }\n\n\n    // Set the values for Reflection section fields\n    if (blogData.reflection) {\n        document.getElementById('technical_challenges').value = blogData.reflection.technical_challenges || '';\n        document.getElementById('interesting_bugs').value = blogData.reflection.interesting_bugs || '';\n        document.getElementById('unanswered_questions').value = blogData.reflection.unanswered_questions || '';\n        document.getElementById('learning_outcomes').value = blogData.reflection.learning_outcomes || '';\n        document.getElementById('next_steps_short_term').value = blogData.reflection.next_steps_short_term || '';\n        document.getElementById('next_steps_long_term').value = blogData.reflection.next_steps_long_term || '';\n\n\n        // Set the self-reflective mood sliders\n        document.getElementById('productivity_level').value = blogData.reflection.productivity_level || 50;\n        document.getElementById('distraction_level').value = blogData.reflection.distraction_level || 50;\n        document.getElementById('desire_to_play_steam_games_level').value = blogData.reflection.desire_to_play_steam_games_level || 50;\n        document.getElementById('overall_frustration_level').value = blogData.reflection.overall_frustration_level || 50;\n    }\n    console.log(`Blog Data: ${JSON.stringify(blogData, null, 2)}`)\n    // Add a new task for however many tasks there are\n    for (let i = 0; i &lt; blogData.tasks.length; i++) {\n        addTask(blogData.tasks[i]); // Add additional tasks\n    }\n    \n    selectTab(1); // Ensure this is called after the DOM is fully loaded\n    \n}\n\n\n\n// Fetch today's blog data using AJAX\ndocument.addEventListener('DOMContentLoaded', function () {\n    fetch('/api/today_blog')\n        .then(response =&gt; response.json())\n        .then(blogData =&gt; {\n            initializeBlog(blogData);\n        })\n        .catch(error =&gt; {\n            console.error('Error fetching blog data:', error);\n        });\n\n\n\n    // Add the event listener to textareas\n    document.querySelectorAll('textarea').forEach(textarea =&gt; {\n        textarea.addEventListener('input', autoResizeTextArea);\n        // Initialize each textarea to resize on page load\n        autoResizeTextArea({ target: textarea });\n    });\n});\n</pre><p><br></p><p>I didn't mistype when I said \"generate\", instead of set data of already existing elements. I originally had the HTML template contain the code for the first task, which defaulted to empty values. This worked fine, until I wanted to start loading in multiple tasks from a given blog. I tried to do this weird thing where I set the values for the first task, and then generated new HTML with formatted values for consecutive tasks. This sucked. It was super hard to keep the HTML on the template and the HTML I generated to be the same. This was a bad way of designing it, which I realized, and changed. Now, the main HTML template has NO HTML elements for the daily tasks on DOM content load. Instead, I will dynamically generate new HTML for each task. Here's the function that adds a new task.</p><pre class=\"ql-syntax\" spellcheck=\"false\">function addTask(taskData) {\n    currentTaskId++;\n    const newTaskId = currentTaskId;\n    console.log(`Current newTaskId: ${newTaskId}`)\n\n\n    // Create the tab button for the new task\n    const tabButton = document.createElement('button');\n    tabButton.textContent = 'Task ' + newTaskId;\n    tabButton.dataset.taskId = newTaskId;\n    tabButton.className = 'task-tab px-4 py-2 text-sm font-medium text-blue-700 hover:text-blue-900 whitespace-nowrap';\n    tabButton.onclick = function () { selectTab(newTaskId); };\n    document.querySelector('.tab-buttons').appendChild(tabButton);\n\n\n    // Populate task fields with values from taskData (if available) or defaults\n    const task_goal = taskData?.task_goal || '';\n    const task_description = taskData?.task_description || '';\n    const task_expected_difficulty = taskData?.task_expected_difficulty || 50;\n    const task_planned_approach = taskData?.task_planned_approach || '';\n    \n    const task_progress_notes = taskData?.task_progress_notes || '';\n    const challenges_encountered = taskData?.challenges_encountered || '';\n    const research_questions = taskData?.research_questions || '';\n    \n    const tools_used = taskData?.tools_used || '';\n    const reflection_successes = taskData?.reflection_successes || '';\n    const reflection_failures = taskData?.reflection_failures || '';\n    const output_or_result = taskData?.output_or_result || '';\n    const time_spent_coding = taskData?.time_spent_coding || '';\n    const time_spent_researching = taskData?.time_spent_researching || '';\n    const time_spent_debugging = taskData?.time_spent_debugging || '';\n    const follow_up_tasks = taskData?.follow_up_tasks || '';\n\n\n    // Create the task content (HTML)\n    const tabContent = document.createElement('div');\n    tabContent.className = 'task-content p-4 border rounded hidden';\n    tabContent.id = `taskContent${newTaskId}`;\n    \n    tabContent.innerHTML = `\n    &lt;!-- Task Start --&gt;\n    &lt;div class=\"task-start mb-4 bg-white p-4 border rounded\"&gt;\n        &lt;h3 class=\"font-bold\"&gt;Task Start&lt;/h3&gt;\n        &lt;label for=\"task_goal${newTaskId}\"&gt;Task Goal:&lt;/label&gt;\n        &lt;textarea id=\"task_goal${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Desired outcome or goal for the task...\" oninput=\"autoResizeTextArea(event)\"&gt;${task_goal}&lt;/textarea&gt;\n        \n        &lt;label for=\"task_description${newTaskId}\" class=\"block mt-2\"&gt;Task Description:&lt;/label&gt;\n        &lt;textarea id=\"task_description${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Task description...\" oninput=\"autoResizeTextArea(event)\"&gt;${task_description}&lt;/textarea&gt;\n        \n        &lt;label for=\"task_expected_difficulty${newTaskId}\" class=\"block mt-2\"&gt;Expected Difficulty:&lt;/label&gt;\n        &lt;input type=\"range\" id=\"task_expected_difficulty${newTaskId}\" min=\"1\" max=\"100\" value=\"${task_expected_difficulty}\" class=\"w-full\"&gt;\n        \n        &lt;label for=\"task_planned_approach${newTaskId}\" class=\"block mt-2\"&gt;Planned Approach:&lt;/label&gt;\n        &lt;textarea id=\"task_planned_approach${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Planned approach or strategy to solve the problem...\" oninput=\"autoResizeTextArea(event)\"&gt;${task_planned_approach}&lt;/textarea&gt;\n    &lt;/div&gt;\n\n\n    &lt;!-- Task Work --&gt;\n    &lt;div class=\"task-work mb-4 bg-white p-4 border rounded\"&gt;\n        &lt;h3 class=\"font-bold\"&gt;Task Work&lt;/h3&gt;\n        &lt;label for=\"task_progress_notes${newTaskId}\" class=\"block\"&gt;Progress Notes:&lt;/label&gt;\n        &lt;div id=\"task_progress_notes${newTaskId}\" class=\"min-h-[300px]\"&gt;${task_progress_notes}&lt;/div&gt;\n\n\n        &lt;label for=\"challenges_encountered${newTaskId}\" class=\"block mt-4\"&gt;Challenges Encountered:&lt;/label&gt;\n        &lt;textarea id=\"challenges_encountered${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Key challenges or bugs encountered...\" oninput=\"autoResizeTextArea(event)\"&gt;${challenges_encountered}&lt;/textarea&gt;\n\n\n        &lt;label for=\"research_questions${newTaskId}\" class=\"block mt-4\"&gt;Research Questions:&lt;/label&gt;\n        &lt;textarea id=\"research_questions${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"List of research questions that arose while working on the task...\"\n            oninput=\"autoResizeTextArea(event)\"&gt;${research_questions}&lt;/textarea&gt;\n    &lt;/div&gt;\n\n\n    &lt;!-- Task Reflection --&gt;\n    &lt;div class=\"task-reflection mb-4 bg-white p-4 border rounded\"&gt;\n        &lt;h3 class=\"font-bold\"&gt;Task Reflection&lt;/h3&gt;\n\n\n        &lt;label for=\"tools_used${newTaskId}\" class=\"block\"&gt;Tools Used:&lt;/label&gt;\n        &lt;textarea id=\"tools_used${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Key tools, libraries, or frameworks used during the task...\" oninput=\"autoResizeTextArea(event)\"&gt;${tools_used}&lt;/textarea&gt;\n\n\n        &lt;label for=\"reflection_successes${newTaskId}\" class=\"block mt-4\"&gt;Successes:&lt;/label&gt;\n        &lt;textarea id=\"reflection_successes${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"What worked well during the task?\" oninput=\"autoResizeTextArea(event)\"&gt;${reflection_successes}&lt;/textarea&gt;\n\n\n        &lt;label for=\"reflection_failures${newTaskId}\" class=\"block mt-4\"&gt;Failures or Shortcomings:&lt;/label&gt;\n        &lt;textarea id=\"reflection_failures${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"What didn’t work and why?\" oninput=\"autoResizeTextArea(event)\"&gt;${reflection_failures}&lt;/textarea&gt;\n\n\n        &lt;label for=\"output_or_result${newTaskId}\" class=\"block mt-4\"&gt;Output or Result:&lt;/label&gt;\n        &lt;textarea id=\"output_or_result${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"The outcome or deliverable from this task (e.g., code, documentation).\" oninput=\"autoResizeTextArea(event)\"&gt;${output_or_result}&lt;/textarea&gt;\n\n\n        &lt;!-- Time Spent Fields --&gt;\n        &lt;label for=\"time_spent_coding${newTaskId}\" class=\"block mt-4\"&gt;Time Spent Coding:&lt;/label&gt;\n        &lt;input type=\"text\" id=\"time_spent_coding${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded\"\n            placeholder=\"Enter coding time spent (e.g., 2 hours)\" value=\"${time_spent_coding}\"/&gt;\n\n\n        &lt;label for=\"time_spent_researching${newTaskId}\" class=\"block mt-4\"&gt;Time Spent Researching:&lt;/label&gt;\n        &lt;input type=\"text\" id=\"time_spent_researching${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded\"\n            placeholder=\"Enter research time spent (e.g., 30 minutes)\" value=\"${time_spent_researching}\"/&gt;\n\n\n        &lt;label for=\"time_spent_debugging${newTaskId}\" class=\"block mt-4\"&gt;Time Spent Debugging:&lt;/label&gt;\n        &lt;input type=\"text\" id=\"time_spent_debugging${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded\"\n            placeholder=\"Enter debugging time spent (e.g., 45 minutes)\" value=\"${time_spent_debugging}\"/&gt;\n\n\n        &lt;label for=\"follow_up_tasks${newTaskId}\" class=\"block mt-4\"&gt;Follow-Up Tasks:&lt;/label&gt;\n        &lt;textarea id=\"follow_up_tasks${newTaskId}\" class=\"w-full p-2 border border-gray-300 rounded min-h-[150px]\"\n            placeholder=\"Immediate next steps or follow-up tasks...\" oninput=\"autoResizeTextArea(event)\"&gt;${follow_up_tasks}&lt;/textarea&gt;\n    &lt;/div&gt;\n\n\n    &lt;button type=\"button\" onclick=\"removeTask(${newTaskId})\"\n        class=\"mt-2 px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600\"&gt;Remove Task&lt;/button&gt;\n    `;\n\n\n    document.getElementById('tabContent').appendChild(tabContent);\n    \n    // Initialize the Quill editor for the task progress notes\n    initializeEditor(newTaskId, task_progress_notes);\n\n\n    // Select the new task tab\n    selectTab(newTaskId);\n\n\n    // Resize all newly added textAreas\n    document.querySelectorAll('textarea').forEach(textarea =&gt; {\n        autoResizeTextArea({ target: textarea });\n    });\n</pre><p>If you're a smarter person than me, you'll instantly see a problem with this approach. Although much more elegant, there's a slight problem. What happens when there's not an already initialized blog for the day?? Well, to handle this I would initialize an empty Pydantic model in my backend, if there wasn't already a row in the database for today's blog. The problem is that I set the default value for the tasks field to an empty list. In the above script, it iterates through the 'blogData.tasks.length'. Well that would be 0, and an empty task would never be added for the beautiful writer to populate. I could write a separate function to create a fallback task HTML generation? No, that's dumb. I went for the simple approach of changing the Pydantic model code. The 'task' submodel has all optional fields, and all of their defaults are already set (empty strings, or some number for numeric). An 'empty' task submodel could simply be initialized automatically, if there's no data present. So I changed one single line of my Pydantic file: I made a default_factory with a lambda to simply initialize a list, with an empty Task model, if no value was provided. Done. Everything worked. Seriously, that's the solution. I love Pydantic. </p><p><br></p><p>That's about the end of the daily work. To recap, I've done some thinking work to decide on what my blog should look like, I did some research and decided on a tech stack, I iterated on a Pydantic model and SQL schema concurrently, built a super basic Flask backend, connected it to my database with my custom Pydantic functions, iterated on a relatively simple frontend, and then built some javascript scripts to read in data of a blog and populate the fields! I spent some time testing out Quill, which is a rich text editor, which is what allows me to embed pictures and code chunks into this text! I think I'm ready to move on to the next task, which in reality is finishing the blog (I have some retroactive writing to do, now that \"Blog Builder\" is usable\"). See you in the reflection!</p>",
            "challenges_encountered": "It took me longer than that to figure out why I couldn't install 'pip install dotenv', one of the python libraries. Turns out it's named python-dotenv. Stupid. Thought my virtual environment was all messed up when it turns out I just tried to pip install the wrong thing.\n\nI had to get used to Flask's structure. It's very similar to FastAPI, which I have more experience with, but I had to do some light research into how the Flask routes actually interacted with my javascript scripts.\n\nOne of the challenges was trying to auto-fill a template with some initial data. Flask has this render_template function (render_template('home.html', today_blog=today_blog, today_date=today_date)) which loads a given template. I did not realize that you could pass data into the template! I started simple, by passing in the date and autofilling at the top of the \"Blog Builder\" page. However, to my utter astonishment, I learned that you can pass Pydantic models into Javascript and use the Jinja2 syntax to access the data! This led me to experiment with passing in a day's given Pydantic model for an incomplete blog post, and auto populating the template using this method. Later on I modified this approach, as it was difficult to iterate over all of the possible Tasks in the model and generate Javascript. I ended up using a less advanced approach, where I offered up an API route in Flask to get the day's blog. I created a Javascript function that when the DOM was loaded, I would call my backend to get the daily blog (as JSON this time), and then set the inner HTML of all the \"Introduction\" and \"Reflection\" text areas. For the 1 to N possible \"Tasks\", I generated N total new Divs from a template, autofilling in the template. This worked perfectly. This could allow some kind of vulnerabilities for injecting malicious Javascript, but right now I don't care. It works, only I use it, and the \"Blog Builder\" was never planned to be on anywhere near a server that I don't personally run with Flask. Fuck it. \n\nCSS. I hate CSS. It's ALWAYS a challenge for me to create something that looks good. Most of my process for doing any kind of HTML and CSS styling goes like the following: 1. Get a general idea of what I want. 2. Prompt GPT-4-turbo to give me an acceptable HTML skeleton. 3. Tweak HTML. 4. Have GPT-4 generate inline tailwind CSS to \"make it look better\" and \"fix spacing\" and \"be creative\". This sometimes works, and allows me a shot at making it look somewhat acceptable. 5. Take time to CORRECTLY apply GPT-4s styling to the entire page. Make minor tweaks, fix its weird bugs. You get it. It's always a challenge, and a tarpit I have to stop myself from walking into. \n\nWhen I implemented Quill, the rich text editor for Javascript, it was super simple to implement. One script in the <head>, a couple of settings, and a GPT generated javascript to handle file uploads: Voila! I can now embed pictures, codes, and have access to nice formatting stuff. I made a decision to only implement it for the Progress Notes of each task. This was initally just so I could test it out, and I really liked the simplicity of regular good old <textarea> in HTML. We'll see if I really want to embed pictures and code into other fields. However, as I was testing out Quill, I noticed that the upload picture functionality was working fine but had some stylistic things that irritated me. Mostly, uploaded screenshots were HUGE and took up most of the space for writing. It was difficult for me to write around, and it annoyed me so much that I wrote a function to automatically resize pictures when uploaded. Quill works by uploading pictures as <img> tags, by default only with the 'src' attribute. That src always pointed at the relative filepath to my \"daily-blog-builder\" repository, where the Flask app lived. I wanted to resize automatically all embedded images. I wrote a small script that ran right after the upload image function, it would find all <img> tags in the Quill textArea and then add a style attribute to resize it. Worked great! I could see now! However, about an hour later, I was further testing Quill's ability to embed code blocks. I saved and loaded the blog from SQL and low and behold, all my images were whale sized again. Wtf. I started paradoxically by checking my database. Had I stored them wrong somehow in the upload blog function? And inside my database set the correct <img> tag (embedded in text of course), with the correct style attribute. It was a problem with loading blogData from SQL into my frontend. I debugged throughout the process of loading. SQL -> Backend: fine. Backend -> Frontend: fine. Frontend -> Script Function: fine. The only possible point of error had to be the way Quill took in data to initialize a text area. I did an extensive google search and found a similar github issue. Someone had the exact same problem: saved quill text to a database, loaded from database and tried to initialize Quill with an <img> tag. Although he had a different attribute than style, it was the exact same problem. Apparently, Quill automatically sanitizes all attributes except for \"src\", as a security feature. There did not seem to be an easy way of overriding this functionality. Some absolute gigachad had a solution: He extended Quill's ImageFormatter class to stop being a little bitch and allow other attributes. Then inside the script function, you had to register with the Quill class that you wanted to use the gigachad image formatter instead. Worked! Great stuff. Now I can see again on my blog.",
            "research_questions": "What's the meaning of life?\nHow can I automatically resize images in a Quill text element?\nI need to a deeper dive into Jinja2 syntax. What is the syntax for using the {{ }} value insertion? It did not work within an embedded <script> tag in the HTML, but works inside the HTML body just fine.\nWhat's a better system for versioning my Pydantic SQL utility functions between many different repositories?",
            "tools_used": "Backend: Flask, Python, Pydantic, my custom SQL Pydantic functions <3\nFrontend: HTML, CSS,  Javascript (No react or NextJS, what a breath of fresh air), tailwind, Quill\nDatabase: PostgreSQL, JSONB shoutout\nResearch: ChatGPT (GPT-4-Turbo until I got rate limited), Google, My brain (what an asset)",
            "reflection_successes": "My design and research process went very well, considering I had a pretty narrow preset idea on what an ideal approach might be. Setting up the Flask app was incredibly fast. Getting database integrated was a breeze, as I'm very familiar with using PostgreSQL + Pydantic + Python. Rapid iteration of frontend HTML structure was good, however I'll talk about CSS styling in failures. I really think I succeeded in making something relatively simple, relatively fast, and start using it immediately. Full transparency, from 0 to completely usable the \"Blog Builder\" took about 9 hours. Writing the blog unfortunately spilled over into the next morning (I'm cheating a little!). The biggest success is that I'm back building things. I'm happier, more energized, and have much more motivation on my job search. We're so back baby.",
            "reflection_failures": "CSS styling. I hate it, it always is a tarpit, I find myself spending too much time. I tried to let ChatGPT take the wheel as much as possible, and only use myself to polish and standardize formatting. However, I wager I lost probably 1 whole hour to the CSS tarpit. Better than previous projects, but I can get better. \n\nI got a little lazy with building out the script functionality for the HTML frontend. The scripts handled most of the data integrations with the backend. I wasted a lot of time implementing a bad design choice for having a prepopulated \"tasks\" section for the first task in the HTML. When I started implementing loading data from an in progress blog, it really did not work well with the prepopulated HTML. I implemented a quick hack to set the values for the first of N tasks, and then generate HTML for the remaining tasks. However this was buggy, and led to consistency issues. Any time I updated the HTML or CSS on the template, I had to go into the script code and change the generated HTML. There was incosistency with ids used for reading data. After about 30 minutes of using the hack, I bit the bullet and refactored the blogData loading process. I removed the Task section from the template, and set it up so tasks are always generated dynamically for all tasks. This was just lazy and bad design, where my desire for speed outweighed my desire to make good design decisions. Overall not terrible, but I need to get better at not simply using ChatGPTs suggestions. As project development goes longer, ChatGPTs solutions become more and more buggy and don't connect well with existing code. I know this, and need to be better at being more disciplined when the complexity goes up.\n\nOne very slight failure is my failure to write this blog on time. It's currently Friday, September 6th, and I'm finishing the blog for September 5th. It was slightly ambitious to think I could get a fully working version of the Blog Builder in a single day, test it fully, and also write the blog. I wanted my first blog to be very detailed, and so I'm taking some time to finish this blog before I start working on the next one. I don't know how I feel about \"1 blog a day\", especially if I want to take time to go in depth into technical challenges I face. No doubt I will get faster the more blogs I write, and it will be easier to write blogs as I go, but I'm not opposed to the idea of re-evaluating one blog per day.",
            "output_or_result": "One local Flask application, which provides a \"Daily Blog Builder\" localhost site for writing a blog. Connects to Postgres for data storage, so I can save and load blogs throughout the day. Goal achieved! Excellent!",
            "time_spent_coding": "8 hours",
            "time_spent_researching": "4 hours",
            "time_spent_debugging": "3 hours",
            "follow_up_tasks": "Finish writing this damn blog! And publish it on my website! Really, I'm ready to move on to the tasks of streamlining the blog editing process (with AI pipelines), the design of blogs on my NextJS website, and a system for automatically uploading blogs daily. Onwards!"
        }
    ],
    "reflection": {
        "technical_challenges": "Learning to use flask. Developing code to automatically load in progress blogData, and correctly format it into the HTML frontend. Special difficulty in dynamically generating 1 to N daily tasks. Had some problems learning how to use the Quill editor.",
        "interesting_bugs": "Quill <img> attribute sanitation led to my auto-image resizing failing.\nSee the task for today for more.",
        "unanswered_questions": "What's the meaning of life?\nWhat's a better system for versioning my Pydantic SQL utility functions between many different repositories?",
        "learning_outcomes": "I learned a lot about some more basic web development fundamentals. I don't think it's actually too uncommon nowadays, but I started my web development journey by learning NextJS and React. I got proficient at developing websites with both, however I feel like I lacked some of the fundamental grounding that writing pure HTML and javascript provides. I definitely miss some of NextJS features, but overall am very glad to take a break and get my hands dirty with some of the basics I may have missed. I learned a little bit more about how I can utilize software engineering best practices. I don't think I'm too far off, and think my plan of action was pretty sound. I found problems when my sometimes overreliance on AI generated code (which usually makes me faster) can sometimes backfire, forcing me to spend a good amount of time redesigning and refactoring code. I need to be better at realizing points I need to slow done, think it out, and put on my software engineer hat instead of reaching straight for the LLM crutch. Overall, I don't think its a super important problem, but it helps to do a completely new project and get better at moderating my LLM usage. I learned also that I kinda like writing! It's cathartic. Now I just have to stick to my promises and actually upload these blogs, instead of letting them sit in Postgres.",
        "next_steps_short_term": "Work on integrating some kind of AI editing pipeline. Work on building the website blog functionality, so I actually have a place to upload these blogs I write. Brainstorm some further AI integrations, specifically into real time editing where Dave can critique and ask for clarification/further content to improve the technical depth of my blogs.",
        "next_steps_long_term": "Start posting blogs! Manually at first. Once further research into AI integration is done, I'd love to experiment with completely autonomous editing and upload (kinda scared to let Dave cook with no supervision), but that might be a very interesting premise. Get a job! Seriously working on refocusing myself to get back on the job grind for real. I think this blog at worst will hone my focus, and at best may lead to a super cool hiring manager finding this site and reaching out.",
        "productivity_level": 90,
        "distraction_level": 22,
        "desire_to_play_steam_games_level": 85,
        "overall_frustration_level": 15
    },
    "created_at": "2024-09-05T18:47:08.872638-07:00",
    "updated_at": "2024-09-06T14:30:29.526396-07:00"
}