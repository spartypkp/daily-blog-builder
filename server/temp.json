[
    "<p id=\"task_progress_notes-0\">My day started out by thinking about a list of requirements for the blog builder. I already detailed these requirements in the daily goals. I jumped right into research with ChatGPT, my favorite partner programming rubber ducky. After discussing with ChatGPT, it became clear that Flask would probably be the best choice. It would allow me the most flexibility and speed to MVP. I wanted something simple, and this would do the trick. I can use Python for my entire backend, while also using Pydantic models to pass data in a more structured way. I already extensively use Pydantic when interacting with SQL tables, and imported some of my common used functions. The function I show below is a simple generic python function for writing a select query on a given table, and returning all results as a List of pydantic models. Provide the table name, and the Pydantic type you want returned, and bam it works. It is considered bad practice to use Python f string formatting to inject the table name directly, however I don't care. I will always be manually specifying the table name, which is never derived from user input. I have some experimental versions of this function which use more safe Psycopg3 parameterized inputs, but that's still in development. I currently have separate functions for all the main SQL query types. In the future, I hope to finish my work on developing a generic function and library for interacting with SQL purely through Pydantic Models (which can be auto generated!). This will likely be a future blog post, so stick around!</p>",
    "<p id=\"task_progress_notes-3\">As I was looking for that pydantic_select function, I realized I have the same function defined in 10 different repositories. Some are slightly different, with slight enhancements and changes I've made throuhgout my Pydantic journey. I really need to go back and standardize. I think I need a better system for versioning across repos. Putting a mental note to be a smarter software engineer and find a solution for that.</p>",
    "<p id=\"task_progress_notes-5\">The next step is of course to design the schema and structure of a daily blog post. I need to decide on what information I need to capture each day in all my blogs. How do I want to go about designing this? I started this process by deciding to split a given single blog post into 3 separate sections. There's an introduction, which occurs at the beginning of each day, and contains information about my goals, description of the problem, plan of attack, and some other fun mood sliders. The last section is the reflection, where I can reflect on the progress of the day and how i did or did not achieve my goals. I struggled to come up with a solid idea for tracking my work during the bulk of the day, where I'm working on different projects and tasks for different amount of time. I could be working on scraping legislation, practicing leetcode, working my part time AI Engineer consulting job, or building numerous different side projects. I needed something flexible that allowed me to track multiple different unique tasks throughout the day. I decided on building a dynamic task system, where I could track progress for 1 to N number of tasks I complete during the day. How I break up my goals into tasks will be left completely up to me (for now, maybe I'll integrate Dave to help me later). Each task has information on the task, description, and tracks some important information like \"Challenges Encountered\" and \"Research Questions\".</p>",
    "<p id=\"task_progress_notes-7\">The first step to implementing my blog schema is to structure my thoughts into you guessed it, a Pydantic model! And because I love Pydantic and Postgres so much, I can concurrently create the schema for my backend data and my database. I map Pydantic models directly into PostgreSQL table schemas. The trick is to use JSONB for complex nested fields, which the corresponding Pydantic model represents as another Pydantic model! This allows for rapid iteration of design. As long as I get some of the key metadata fields right, I can effortlessly update how I structure and store data without ever having to worry about updating SQL schema. This can be incredibly important when doing rapid prompt engineering. In this case, I've developed Pydantic models for the \"Introduction\", \"Tasks\", and \"Reflection\" sections of each Daily Blog. Those are represented as JSONB in SQL, and have their own submodels in Python. Here's the code!</p>",
    "<p id=\"task_progress_notes-9\">I really enjoy using the Field() feature of Pydantic, which allows me to set default values and add extensive descriptions, as well as constraints for improved automatic value validation. Also, I hope you see how I avoid using camelCase like the plague. I want the name of my Pydantic model fields to EXACTLY match the SQL column names. Now this naming, doesn't technically matter for submodels, which will be thrown into JSONB, but I like to be consistent. Speaking of JSONB, here's the SQL schema for the daily_blogs table!</p>",
    "<p id=\"task_progress_notes-12\">Shout out Postico, the best investment I ever made. As you can see, this table is brutally simple. I like to keep complex design and typing within the backend and out of the database. JSONB is great because it allows for incredible flexiblity in rapid iteration of schema, and I can still create complex SQL queries which access underlying data within JSONB columns. To my naive junior software development mind, this is an acceptable tradeoff. I love it.</p>",
    "<p id=\"task_progress_notes-14\">I now need to set up my backend, super simple at first. I'm using Flask, and only need a couple of main routes.</p>",
    "<p id=\"task_progress_notes-15\">My file system structure is stupid simple, and took me and ChatGPT about 5 minutes to setup.</p>",
    "<p id=\"task_progress_notes-18\">I've got a super simple setup here. I've got a home route, which gets the current blog for the day or creates an empty one, and then renders the home page with it.</p>",
    "<ul id=\"task_progress_notes-19\"><li>/api/today_blog route offers up the daily blog. It's useful because my Javascript function will ask for the daily blog to populate all of the daily tasks dynamically. I'm just now noticing it has a /api/ in the route. Bad ChatGPT, that's completely unnecessary.</li><li>/submit_blog reads in the values of all my forms and text areas for a daily blog, loads it into a Pydantic model, and then saves it to Postgres. Simple.</li><li>/upload_image is a route that handles the saving of image uploads into the repository. This is necessary to override the default functionality of Quill, a rich text editor for Javascript.</li></ul>",
    "<p id=\"task_progress_notes-20\">Next it was necessary to start working on the frontend. To be honest, I worked simultaneously on the frontend as I was building out some of the functionality of the API routes. But for easier understanding, I'm talking about these two separately. First step was to start building out the frontend. I started by prompting ChatGPT to develop 3 distinct sections of content in the body, as well as set up Tailwind and the rest of the HTML document. There are 3 distinct sections corresponding to the Pydantic Model: introduction, tasks, and of course reflection. Here's an image of a VERY early version of the frontend.</p>",
    "<p id=\"task_progress_notes-23\">After some iteration, I was able to fully flesh out the correct input areas for ALL of the fields of the Pydantic model. I was very careful to make the ID of each input element the exact field name of the Pydantic model, to allow for super easy access. Smort. To be completely honest, this is the point where a lot of design iteration happened. I redesigned my Pydantic model a lot. I added new fields. I tested out new HTML. At this point I even started to write a partial blog. However, this blog eventually had to be overwritten, as I made simply too much radical changes to the Pydantic model schema and SQL table, and opted to simply restart. So if you feel as if I'm extra omnitient in this blog, that's why! I really do want to focus on writing the blogs more as I go, but I'll cut myself some slack as this is my first blog. Also, it's very difficult to use a tool which you are in the process of developing. So cut me some slack Dave. Here's a finalized version of the current introduction section, filled with text I am currently writing for the blog.</p>",
    "<p id=\"task_progress_notes-25\">My next step was to connect my frontend with my backend. I needed to write a bunch of different scripts, which would handle data loading between my backend. Possibly the most important function is the initializeBlog() function. This function takes in a Pydantic model of the blog data, dumped to JSON, and uses it to set the html of all my data input HTML elements. Simple, but works. And because I made the id of each element to map directly to my Pydantic model field names, it's super clean and easy. After adding all of the introduction and reflection sections, I have to iterate over all of the possible daily tasks and generate those separately. Onward!</p>",
    "<p id=\"task_progress_notes-29\">I didn't mistype when I said \"generate\", instead of set data of already existing elements. I originally had the HTML template contain the code for the first task, which defaulted to empty values. This worked fine, until I wanted to start loading in multiple tasks from a given blog. I tried to do this weird thing where I set the values for the first task, and then generated new HTML with formatted values for consecutive tasks. This sucked. It was super hard to keep the HTML on the template and the HTML I generated to be the same. This was a bad way of designing it, which I realized, and changed. Now, the main HTML template has NO HTML elements for the daily tasks on DOM content load. Instead, I will dynamically generate new HTML for each task. Here's the function that adds a new task.</p>",
    "<p id=\"task_progress_notes-31\">If you're a smarter person than me, you'll instantly see a problem with this approach. Although much more elegant, there's a slight problem. What happens when there's not an already initialized blog for the day?? Well, to handle this I would initialize an empty Pydantic model in my backend, if there wasn't already a row in the database for today's blog. The problem is that I set the default value for the tasks field to an empty list. In the above script, it iterates through the 'blogData.tasks.length'. Well that would be 0, and an empty task would never be added for the beautiful writer to populate. I could write a separate function to create a fallback task HTML generation? No, that's dumb. I went for the simple approach of changing the Pydantic model code. The 'task' submodel has all optional fields, and all of their defaults are already set (empty strings, or some number for numeric). An 'empty' task submodel could simply be initialized automatically, if there's no data present. So I changed one single line of my Pydantic file: I made a default_factory with a lambda to simply initialize a list, with an empty Task model, if no value was provided. Done. Everything worked. Seriously, that's the solution. I love Pydantic.</p>",
    "<p id=\"task_progress_notes-33\">That's about the end of the daily work. To recap, I've done some thinking work to decide on what my blog should look like, I did some research and decided on a tech stack, I iterated on a Pydantic model and SQL schema concurrently, built a super basic Flask backend, connected it to my database with my custom Pydantic functions, iterated on a relatively simple frontend, and then built some javascript scripts to read in data of a blog and populate the fields! I spent some time testing out Quill, which is a rich text editor, which is what allows me to embed pictures and code chunks into this text! I think I'm ready to move on to the next task, which in reality is finishing the blog (I have some retroactive writing to do, now that \"Blog Builder\" is usable\"). See you in the reflection!</p>"
  ]